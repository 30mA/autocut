   1               		.file	"LCD.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	LCD_SETPINS
  12               	LCD_SETPINS:
  13               	.LFB10:
  14               		.file 1 "LCD.c"
   1:LCD.c         **** /*
   2:LCD.c         ****  *  File:			LCD.c
   3:LCD.c         ****  * 	Autor:			Simon Schumann
   4:LCD.c         ****  * 	Description:	library for HD44780 LC-displays
   5:LCD.c         ****  * 	Contains:		routines for:	- initialisation
   6:LCD.c         ****  * 									- write:
   7:LCD.c         ****  * 											- characters
   8:LCD.c         ****  * 											- strings
   9:LCD.c         ****  * 											- integers
  10:LCD.c         ****  * 											- floats
  11:LCD.c         ****  * 									- setting cursor position
  12:LCD.c         ****  * 									- set cursor to home position
  13:LCD.c         ****  * 									- clear display
  14:LCD.c         ****  * 									- generate custom characters
  15:LCD.c         ****  */
  16:LCD.c         **** 
  17:LCD.c         **** #include <avr/io.h>
  18:LCD.c         **** #include <util/delay.h>
  19:LCD.c         **** #include <stdlib.h>
  20:LCD.c         **** #include "LCD.h"
  21:LCD.c         **** 
  22:LCD.c         **** void LCD_SETPINS (type_LCD *device, uint8_t data)
  23:LCD.c         **** {
  15               		.loc 1 23 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26               	/* prologue: function */
  27               	/* frame size = 0 */
  28               	/* stack size = 2 */
  29               	.L__stack_usage = 2
  30 0004 FC01      		movw r30,r24
  24:LCD.c         **** 	*device->port	&=~((1<< device->pinNr_D4)	\
  31               		.loc 1 24 0
  32 0006 C081      		ld r28,Z
  33 0008 D181      		ldd r29,Z+1
  34 000a 4881      		ld r20,Y
  25:LCD.c         **** 					|	(1<< device->pinNr_D5)	\
  35               		.loc 1 25 0
  36 000c 81E0      		ldi r24,lo8(1)
  37 000e 90E0      		ldi r25,0
  38               	.LVL1:
  39 0010 DC01      		movw r26,r24
  40 0012 0184      		ldd r0,Z+9
  41 0014 00C0      		rjmp 2f
  42               		1:
  43 0016 AA0F      		lsl r26
  44 0018 BB1F      		rol r27
  45               		2:
  46 001a 0A94      		dec r0
  47 001c 02F4      		brpl 1b
  24:LCD.c         **** 	*device->port	&=~((1<< device->pinNr_D4)	\
  48               		.loc 1 24 0
  49 001e 9C01      		movw r18,r24
  50 0020 0084      		ldd r0,Z+8
  51 0022 00C0      		rjmp 2f
  52               		1:
  53 0024 220F      		lsl r18
  54 0026 331F      		rol r19
  55               		2:
  56 0028 0A94      		dec r0
  57 002a 02F4      		brpl 1b
  58 002c 2A2B      		or r18,r26
  26:LCD.c         **** 					|	(1<< device->pinNr_D6)	\
  59               		.loc 1 26 0
  60 002e DC01      		movw r26,r24
  61 0030 0284      		ldd r0,Z+10
  62 0032 00C0      		rjmp 2f
  63               		1:
  64 0034 AA0F      		lsl r26
  65 0036 BB1F      		rol r27
  66               		2:
  67 0038 0A94      		dec r0
  68 003a 02F4      		brpl 1b
  24:LCD.c         **** 	*device->port	&=~((1<< device->pinNr_D4)	\
  69               		.loc 1 24 0
  70 003c A22B      		or r26,r18
  27:LCD.c         **** 					|	(1<< device->pinNr_D7));
  71               		.loc 1 27 0
  72 003e 9C01      		movw r18,r24
  73 0040 0384      		ldd r0,Z+11
  74 0042 00C0      		rjmp 2f
  75               		1:
  76 0044 220F      		lsl r18
  77 0046 331F      		rol r19
  78               		2:
  79 0048 0A94      		dec r0
  80 004a 02F4      		brpl 1b
  24:LCD.c         **** 					|	(1<< device->pinNr_D5)	\
  81               		.loc 1 24 0
  82 004c 2A2B      		or r18,r26
  83 004e 2095      		com r18
  84 0050 2423      		and r18,r20
  85 0052 2883      		st Y,r18
  28:LCD.c         **** 	if(	data & 1<<0 ) *device->port	|= 	(1<< device->pinNr_D4);
  86               		.loc 1 28 0
  87 0054 60FF      		sbrs r22,0
  88 0056 00C0      		rjmp .L2
  89               		.loc 1 28 0 is_stmt 0 discriminator 1
  90 0058 A081      		ld r26,Z
  91 005a B181      		ldd r27,Z+1
  92 005c 2C91      		ld r18,X
  93 005e 0084      		ldd r0,Z+8
  94 0060 00C0      		rjmp 2f
  95               		1:
  96 0062 880F      		lsl r24
  97 0064 991F      		rol r25
  98               		2:
  99 0066 0A94      		dec r0
 100 0068 02F4      		brpl 1b
 101 006a 822B      		or r24,r18
 102 006c 8C93      		st X,r24
 103               	.L2:
  29:LCD.c         **** 	if(	data & 1<<1 ) *device->port	|= 	(1<< device->pinNr_D5);
 104               		.loc 1 29 0 is_stmt 1
 105 006e 61FF      		sbrs r22,1
 106 0070 00C0      		rjmp .L3
 107               		.loc 1 29 0 is_stmt 0 discriminator 1
 108 0072 A081      		ld r26,Z
 109 0074 B181      		ldd r27,Z+1
 110 0076 2C91      		ld r18,X
 111 0078 81E0      		ldi r24,lo8(1)
 112 007a 90E0      		ldi r25,0
 113 007c 0184      		ldd r0,Z+9
 114 007e 00C0      		rjmp 2f
 115               		1:
 116 0080 880F      		lsl r24
 117 0082 991F      		rol r25
 118               		2:
 119 0084 0A94      		dec r0
 120 0086 02F4      		brpl 1b
 121 0088 822B      		or r24,r18
 122 008a 8C93      		st X,r24
 123               	.L3:
  30:LCD.c         **** 	if(	data & 1<<2 ) *device->port	|= 	(1<< device->pinNr_D6);
 124               		.loc 1 30 0 is_stmt 1
 125 008c 62FF      		sbrs r22,2
 126 008e 00C0      		rjmp .L4
 127               		.loc 1 30 0 is_stmt 0 discriminator 1
 128 0090 A081      		ld r26,Z
 129 0092 B181      		ldd r27,Z+1
 130 0094 2C91      		ld r18,X
 131 0096 81E0      		ldi r24,lo8(1)
 132 0098 90E0      		ldi r25,0
 133 009a 0284      		ldd r0,Z+10
 134 009c 00C0      		rjmp 2f
 135               		1:
 136 009e 880F      		lsl r24
 137 00a0 991F      		rol r25
 138               		2:
 139 00a2 0A94      		dec r0
 140 00a4 02F4      		brpl 1b
 141 00a6 822B      		or r24,r18
 142 00a8 8C93      		st X,r24
 143               	.L4:
  31:LCD.c         **** 	if(	data & 1<<3 ) *device->port	|= 	(1<< device->pinNr_D7);
 144               		.loc 1 31 0 is_stmt 1
 145 00aa 63FF      		sbrs r22,3
 146 00ac 00C0      		rjmp .L1
 147               		.loc 1 31 0 is_stmt 0 discriminator 1
 148 00ae A081      		ld r26,Z
 149 00b0 B181      		ldd r27,Z+1
 150 00b2 2C91      		ld r18,X
 151 00b4 81E0      		ldi r24,lo8(1)
 152 00b6 90E0      		ldi r25,0
 153 00b8 0384      		ldd r0,Z+11
 154 00ba 00C0      		rjmp 2f
 155               		1:
 156 00bc 880F      		lsl r24
 157 00be 991F      		rol r25
 158               		2:
 159 00c0 0A94      		dec r0
 160 00c2 02F4      		brpl 1b
 161 00c4 822B      		or r24,r18
 162 00c6 8C93      		st X,r24
 163               	.L1:
 164               	/* epilogue start */
  32:LCD.c         **** }
 165               		.loc 1 32 0 is_stmt 1
 166 00c8 DF91      		pop r29
 167 00ca CF91      		pop r28
 168 00cc 0895      		ret
 169               		.cfi_endproc
 170               	.LFE10:
 172               	.global	LCD_ENABLE
 174               	LCD_ENABLE:
 175               	.LFB11:
  33:LCD.c         **** 
  34:LCD.c         **** void LCD_ENABLE(type_LCD *device)
  35:LCD.c         **** {
 176               		.loc 1 35 0
 177               		.cfi_startproc
 178               	.LVL2:
 179               	/* prologue: function */
 180               	/* frame size = 0 */
 181               	/* stack size = 0 */
 182               	.L__stack_usage = 0
 183 00ce FC01      		movw r30,r24
  36:LCD.c         **** 	*device->port |= (1<<device->pinNr_EN);
 184               		.loc 1 36 0
 185 00d0 A081      		ld r26,Z
 186 00d2 B181      		ldd r27,Z+1
 187 00d4 4C91      		ld r20,X
 188 00d6 21E0      		ldi r18,lo8(1)
 189 00d8 30E0      		ldi r19,0
 190 00da C901      		movw r24,r18
 191               	.LVL3:
 192 00dc 0680      		ldd r0,Z+6
 193 00de 00C0      		rjmp 2f
 194               		1:
 195 00e0 880F      		lsl r24
 196 00e2 991F      		rol r25
 197               		2:
 198 00e4 0A94      		dec r0
 199 00e6 02F4      		brpl 1b
 200 00e8 842B      		or r24,r20
 201 00ea 8C93      		st X,r24
 202               	.LVL4:
 203               	.LBB25:
 204               	.LBB26:
 205               		.file 2 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2385 2013-05-03 13:14:20Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/avr/include/util/delay.h **** #endif
  41:/usr/avr/include/util/delay.h **** 
  42:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/avr/include/util/delay.h **** #include <math.h>
  45:/usr/avr/include/util/delay.h **** 
  46:/usr/avr/include/util/delay.h **** /** \file */
  47:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/avr/include/util/delay.h ****     \code
  49:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/avr/include/util/delay.h ****     \endcode
  53:/usr/avr/include/util/delay.h **** 
  54:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/avr/include/util/delay.h ****     used.
  58:/usr/avr/include/util/delay.h **** 
  59:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/avr/include/util/delay.h **** 
  68:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/avr/include/util/delay.h **** 
  77:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/avr/include/util/delay.h **** 
  81:/usr/avr/include/util/delay.h **** */
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/avr/include/util/delay.h **** #endif
  87:/usr/avr/include/util/delay.h **** 
  88:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/avr/include/util/delay.h **** #endif
  93:/usr/avr/include/util/delay.h **** 
  94:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/avr/include/util/delay.h **** #endif
  97:/usr/avr/include/util/delay.h **** 
  98:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/avr/include/util/delay.h **** #endif
 103:/usr/avr/include/util/delay.h **** 
 104:/usr/avr/include/util/delay.h **** /**
 105:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/avr/include/util/delay.h **** 
 107:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/avr/include/util/delay.h **** 
 109:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/avr/include/util/delay.h **** 
 112:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/avr/include/util/delay.h **** 
 114:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/avr/include/util/delay.h **** 
 120:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/avr/include/util/delay.h **** 
 125:/usr/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/avr/include/util/delay.h **** 
 132:/usr/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/avr/include/util/delay.h **** 
 140:/usr/avr/include/util/delay.h ****  */
 141:/usr/avr/include/util/delay.h **** void
 142:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/avr/include/util/delay.h **** {
 144:/usr/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/avr/include/util/delay.h **** 
 155:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/avr/include/util/delay.h **** 
 158:/usr/avr/include/util/delay.h **** 	#else
 159:/usr/avr/include/util/delay.h **** 		//round up by default
 160:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/avr/include/util/delay.h **** 	#endif
 162:/usr/avr/include/util/delay.h **** 
 163:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/avr/include/util/delay.h **** 
 165:/usr/avr/include/util/delay.h **** #else
 166:/usr/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/avr/include/util/delay.h **** 	{
 172:/usr/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/avr/include/util/delay.h **** 		{
 176:/usr/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/avr/include/util/delay.h **** 		}
 180:/usr/avr/include/util/delay.h **** 		return;
 181:/usr/avr/include/util/delay.h **** 	}
 182:/usr/avr/include/util/delay.h **** 	else
 183:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/avr/include/util/delay.h **** #endif
 186:/usr/avr/include/util/delay.h **** }
 187:/usr/avr/include/util/delay.h **** 
 188:/usr/avr/include/util/delay.h **** /**
 189:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/avr/include/util/delay.h **** 
 191:/usr/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/avr/include/util/delay.h **** 
 193:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/avr/include/util/delay.h **** 
 196:/usr/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/avr/include/util/delay.h **** 
 198:/usr/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/avr/include/util/delay.h **** 
 202:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/avr/include/util/delay.h ****   
 207:/usr/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/avr/include/util/delay.h **** 
 211:/usr/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/avr/include/util/delay.h ****  
 214:/usr/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/avr/include/util/delay.h **** 
 222:/usr/avr/include/util/delay.h ****  */
 223:/usr/avr/include/util/delay.h **** void
 224:/usr/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/avr/include/util/delay.h **** {
 226:/usr/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/avr/include/util/delay.h **** 
 234:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/avr/include/util/delay.h **** 
 237:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/avr/include/util/delay.h **** 
 240:/usr/avr/include/util/delay.h **** 	#else
 241:/usr/avr/include/util/delay.h **** 		//round up by default
 242:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/avr/include/util/delay.h **** 	#endif
 244:/usr/avr/include/util/delay.h **** 
 245:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 206               		.loc 2 245 0
 207 00ec 84E0      		ldi r24,lo8(4)
 208 00ee 8A95      		1: dec r24
 209 00f0 01F4      		brne 1b
 210               	.LBE26:
 211               	.LBE25:
  37:LCD.c         **** 	_delay_us(DELAY_EN_us);
  38:LCD.c         **** 	*device->port &=~ (1<<device->pinNr_EN);
 212               		.loc 1 38 0
 213 00f2 A081      		ld r26,Z
 214 00f4 B181      		ldd r27,Z+1
 215 00f6 8C91      		ld r24,X
 216 00f8 0680      		ldd r0,Z+6
 217 00fa 00C0      		rjmp 2f
 218               		1:
 219 00fc 220F      		lsl r18
 220 00fe 331F      		rol r19
 221               		2:
 222 0100 0A94      		dec r0
 223 0102 02F4      		brpl 1b
 224 0104 2095      		com r18
 225 0106 2823      		and r18,r24
 226 0108 2C93      		st X,r18
 227 010a 0895      		ret
 228               		.cfi_endproc
 229               	.LFE11:
 231               	.global	LCD_WRITE
 233               	LCD_WRITE:
 234               	.LFB12:
  39:LCD.c         **** }
  40:LCD.c         **** 
  41:LCD.c         **** void LCD_WRITE(type_LCD *device, uint8_t data_cmd, uint8_t data)
  42:LCD.c         **** {
 235               		.loc 1 42 0
 236               		.cfi_startproc
 237               	.LVL5:
 238 010c FF92      		push r15
 239               	.LCFI2:
 240               		.cfi_def_cfa_offset 3
 241               		.cfi_offset 15, -2
 242 010e 0F93      		push r16
 243               	.LCFI3:
 244               		.cfi_def_cfa_offset 4
 245               		.cfi_offset 16, -3
 246 0110 1F93      		push r17
 247               	.LCFI4:
 248               		.cfi_def_cfa_offset 5
 249               		.cfi_offset 17, -4
 250 0112 CF93      		push r28
 251               	.LCFI5:
 252               		.cfi_def_cfa_offset 6
 253               		.cfi_offset 28, -5
 254 0114 DF93      		push r29
 255               	.LCFI6:
 256               		.cfi_def_cfa_offset 7
 257               		.cfi_offset 29, -6
 258               	/* prologue: function */
 259               	/* frame size = 0 */
 260               	/* stack size = 5 */
 261               	.L__stack_usage = 5
 262 0116 EC01      		movw r28,r24
 263 0118 F62E      		mov r15,r22
  43:LCD.c         **** 	uint8_t data_lowNibble = data & 0x0F;
 264               		.loc 1 43 0
 265 011a 142F      		mov r17,r20
 266 011c 1F70      		andi r17,lo8(15)
 267               	.LVL6:
  44:LCD.c         **** 	uint8_t data_highNibble = (data >> 4) & 0x0F;
 268               		.loc 1 44 0
 269 011e 042F      		mov r16,r20
 270 0120 0295      		swap r16
 271 0122 0F70      		andi r16,lo8(15)
 272               	.LVL7:
  45:LCD.c         **** 	LCD_SETPINS(device, 0x0F);
 273               		.loc 1 45 0
 274 0124 6FE0      		ldi r22,lo8(15)
 275               	.LVL8:
 276 0126 00D0      		rcall LCD_SETPINS
 277               	.LVL9:
  46:LCD.c         **** 	if(data_cmd == LCD_CMD)
 278               		.loc 1 46 0
 279 0128 81E0      		ldi r24,lo8(1)
  47:LCD.c         **** 		*device->port	&=~	(1<< device->pinNr_RS);
 280               		.loc 1 47 0
 281 012a E881      		ld r30,Y
 282 012c F981      		ldd r31,Y+1
 283 012e 2081      		ld r18,Z
  46:LCD.c         **** 	if(data_cmd == LCD_CMD)
 284               		.loc 1 46 0
 285 0130 F812      		cpse r15,r24
 286 0132 00C0      		rjmp .L21
 287               		.loc 1 47 0
 288 0134 81E0      		ldi r24,lo8(1)
 289 0136 90E0      		ldi r25,0
 290 0138 0F80      		ldd r0,Y+7
 291 013a 00C0      		rjmp 2f
 292               		1:
 293 013c 880F      		lsl r24
 294 013e 991F      		rol r25
 295               		2:
 296 0140 0A94      		dec r0
 297 0142 02F4      		brpl 1b
 298 0144 8095      		com r24
 299 0146 8223      		and r24,r18
 300 0148 00C0      		rjmp .L23
 301               	.L21:
  48:LCD.c         **** 	else
  49:LCD.c         **** 		*device->port	|=	(1<< device->pinNr_RS);
 302               		.loc 1 49 0
 303 014a 81E0      		ldi r24,lo8(1)
 304 014c 90E0      		ldi r25,0
 305 014e 0F80      		ldd r0,Y+7
 306 0150 00C0      		rjmp 2f
 307               		1:
 308 0152 880F      		lsl r24
 309 0154 991F      		rol r25
 310               		2:
 311 0156 0A94      		dec r0
 312 0158 02F4      		brpl 1b
 313 015a 822B      		or r24,r18
 314               	.L23:
 315 015c 8083      		st Z,r24
  50:LCD.c         **** 	*device->port	&=~	(1<< device->pinNr_EN);
 316               		.loc 1 50 0
 317 015e E881      		ld r30,Y
 318 0160 F981      		ldd r31,Y+1
 319 0162 2081      		ld r18,Z
 320 0164 81E0      		ldi r24,lo8(1)
 321 0166 90E0      		ldi r25,0
 322 0168 0E80      		ldd r0,Y+6
 323 016a 00C0      		rjmp 2f
 324               		1:
 325 016c 880F      		lsl r24
 326 016e 991F      		rol r25
 327               		2:
 328 0170 0A94      		dec r0
 329 0172 02F4      		brpl 1b
 330 0174 8095      		com r24
 331 0176 8223      		and r24,r18
 332 0178 8083      		st Z,r24
  51:LCD.c         **** 	LCD_SETPINS(device, data_highNibble);
 333               		.loc 1 51 0
 334 017a 602F      		mov r22,r16
 335 017c CE01      		movw r24,r28
 336 017e 00D0      		rcall LCD_SETPINS
 337               	.LVL10:
  52:LCD.c         **** 	LCD_ENABLE(device);
 338               		.loc 1 52 0
 339 0180 CE01      		movw r24,r28
 340 0182 00D0      		rcall LCD_ENABLE
 341               	.LVL11:
 342               	.LBB27:
 343               	.LBB28:
 344               		.loc 2 245 0
 345 0184 94EB      		ldi r25,lo8(-76)
 346 0186 9A95      		1: dec r25
 347 0188 01F4      		brne 1b
 348               	.LBE28:
 349               	.LBE27:
  53:LCD.c         **** 	_delay_us(45);
  54:LCD.c         **** 	LCD_SETPINS(device, data_lowNibble);
 350               		.loc 1 54 0
 351 018a 612F      		mov r22,r17
 352 018c CE01      		movw r24,r28
 353 018e 00D0      		rcall LCD_SETPINS
 354               	.LVL12:
  55:LCD.c         **** 	LCD_ENABLE(device);
 355               		.loc 1 55 0
 356 0190 CE01      		movw r24,r28
 357 0192 00D0      		rcall LCD_ENABLE
 358               	.LVL13:
 359               	.LBB29:
 360               	.LBB30:
 163:/usr/avr/include/util/delay.h **** 
 361               		.loc 2 163 0
 362 0194 8FE6      		ldi r24,lo8(5999)
 363 0196 97E1      		ldi r25,hi8(5999)
 364 0198 0197      		1: sbiw r24,1
 365 019a 01F4      		brne 1b
 366 019c 00C0      		rjmp .
 367 019e 0000      		nop
 368               	.LBE30:
 369               	.LBE29:
  56:LCD.c         **** 	_delay_ms(2);
  57:LCD.c         **** 	LCD_SETPINS(device, 0);
 370               		.loc 1 57 0
 371 01a0 60E0      		ldi r22,0
 372 01a2 CE01      		movw r24,r28
 373               	/* epilogue start */
  58:LCD.c         **** }
 374               		.loc 1 58 0
 375 01a4 DF91      		pop r29
 376 01a6 CF91      		pop r28
 377               	.LVL14:
 378 01a8 1F91      		pop r17
 379               	.LVL15:
 380 01aa 0F91      		pop r16
 381               	.LVL16:
 382 01ac FF90      		pop r15
 383               	.LVL17:
  57:LCD.c         **** }
 384               		.loc 1 57 0
 385 01ae 00C0      		rjmp LCD_SETPINS
 386               	.LVL18:
 387               		.cfi_endproc
 388               	.LFE12:
 390               	.global	LCD_STRING
 392               	LCD_STRING:
 393               	.LFB13:
  59:LCD.c         **** 
  60:LCD.c         **** void LCD_STRING(type_LCD *device, char *string)
  61:LCD.c         **** {
 394               		.loc 1 61 0
 395               		.cfi_startproc
 396               	.LVL19:
 397 01b0 0F93      		push r16
 398               	.LCFI7:
 399               		.cfi_def_cfa_offset 3
 400               		.cfi_offset 16, -2
 401 01b2 1F93      		push r17
 402               	.LCFI8:
 403               		.cfi_def_cfa_offset 4
 404               		.cfi_offset 17, -3
 405 01b4 CF93      		push r28
 406               	.LCFI9:
 407               		.cfi_def_cfa_offset 5
 408               		.cfi_offset 28, -4
 409 01b6 DF93      		push r29
 410               	.LCFI10:
 411               		.cfi_def_cfa_offset 6
 412               		.cfi_offset 29, -5
 413               	/* prologue: function */
 414               	/* frame size = 0 */
 415               	/* stack size = 4 */
 416               	.L__stack_usage = 4
 417 01b8 8C01      		movw r16,r24
 418 01ba EB01      		movw r28,r22
 419               	.LVL20:
 420               	.L25:
  62:LCD.c         **** 	while(*string)
 421               		.loc 1 62 0
 422 01bc 4991      		ld r20,Y+
 423               	.LVL21:
 424 01be 4423      		tst r20
 425 01c0 01F0      		breq .L27
 426               	.LVL22:
  63:LCD.c         **** 		LCD_WRITE(device, LCD_DATA, *string++);
 427               		.loc 1 63 0
 428 01c2 60E0      		ldi r22,0
 429 01c4 C801      		movw r24,r16
 430 01c6 00D0      		rcall LCD_WRITE
 431               	.LVL23:
 432 01c8 00C0      		rjmp .L25
 433               	.LVL24:
 434               	.L27:
 435               	/* epilogue start */
  64:LCD.c         **** }
 436               		.loc 1 64 0
 437 01ca DF91      		pop r29
 438 01cc CF91      		pop r28
 439               	.LVL25:
 440 01ce 1F91      		pop r17
 441 01d0 0F91      		pop r16
 442               	.LVL26:
 443 01d2 0895      		ret
 444               		.cfi_endproc
 445               	.LFE13:
 447               	.global	LCD_CLEAR
 449               	LCD_CLEAR:
 450               	.LFB14:
  65:LCD.c         **** 
  66:LCD.c         **** 
  67:LCD.c         **** void LCD_CLEAR(type_LCD *device)
  68:LCD.c         **** {
 451               		.loc 1 68 0
 452               		.cfi_startproc
 453               	.LVL27:
 454               	/* prologue: function */
 455               	/* frame size = 0 */
 456               	/* stack size = 0 */
 457               	.L__stack_usage = 0
  69:LCD.c         **** 	LCD_WRITE(device, LCD_CMD, 0x01);
 458               		.loc 1 69 0
 459 01d4 41E0      		ldi r20,lo8(1)
 460 01d6 61E0      		ldi r22,lo8(1)
 461 01d8 00C0      		rjmp LCD_WRITE
 462               	.LVL28:
 463               		.cfi_endproc
 464               	.LFE14:
 466               	.global	LCD_HOME
 468               	LCD_HOME:
 469               	.LFB15:
  70:LCD.c         **** }
  71:LCD.c         **** 
  72:LCD.c         **** void LCD_HOME(type_LCD *device)
  73:LCD.c         **** {
 470               		.loc 1 73 0
 471               		.cfi_startproc
 472               	.LVL29:
 473               	/* prologue: function */
 474               	/* frame size = 0 */
 475               	/* stack size = 0 */
 476               	.L__stack_usage = 0
  74:LCD.c         **** 	LCD_WRITE(device, LCD_CMD, 0x02);
 477               		.loc 1 74 0
 478 01da 42E0      		ldi r20,lo8(2)
 479 01dc 61E0      		ldi r22,lo8(1)
 480 01de 00C0      		rjmp LCD_WRITE
 481               	.LVL30:
 482               		.cfi_endproc
 483               	.LFE15:
 485               	.global	LCD_POS
 487               	LCD_POS:
 488               	.LFB16:
  75:LCD.c         **** }
  76:LCD.c         **** 
  77:LCD.c         **** void LCD_POS(type_LCD *device, uint8_t line, uint8_t column)
  78:LCD.c         **** {
 489               		.loc 1 78 0
 490               		.cfi_startproc
 491               	.LVL31:
 492               	/* prologue: function */
 493               	/* frame size = 0 */
 494               	/* stack size = 0 */
 495               	.L__stack_usage = 0
  79:LCD.c         **** 	LCD_WRITE(device, LCD_CMD, 0b10000000 + line*64 + column);
 496               		.loc 1 79 0
 497 01e0 20E4      		ldi r18,lo8(64)
 498 01e2 629F      		mul r22,r18
 499 01e4 400D      		add r20,r0
 500 01e6 1124      		clr __zero_reg__
 501               	.LVL32:
 502 01e8 4058      		subi r20,lo8(-(-128))
 503 01ea 61E0      		ldi r22,lo8(1)
 504               	.LVL33:
 505 01ec 00C0      		rjmp LCD_WRITE
 506               	.LVL34:
 507               		.cfi_endproc
 508               	.LFE16:
 510               	.global	LCD_INTX
 512               	LCD_INTX:
 513               	.LFB18:
  80:LCD.c         **** }
  81:LCD.c         **** 
  82:LCD.c         **** void LCD_INT(type_LCD *device, uint16_t number)
  83:LCD.c         **** {
  84:LCD.c         **** 	LCD_INTX(device, number, DEC, 0);
  85:LCD.c         **** }
  86:LCD.c         **** 
  87:LCD.c         **** void LCD_INTX(type_LCD *device, uint16_t number, uint8_t format, uint8_t digits)
  88:LCD.c         **** {
 514               		.loc 1 88 0
 515               		.cfi_startproc
 516               	.LVL35:
 517 01ee 0F93      		push r16
 518               	.LCFI11:
 519               		.cfi_def_cfa_offset 3
 520               		.cfi_offset 16, -2
 521 01f0 1F93      		push r17
 522               	.LCFI12:
 523               		.cfi_def_cfa_offset 4
 524               		.cfi_offset 17, -3
 525 01f2 CF93      		push r28
 526               	.LCFI13:
 527               		.cfi_def_cfa_offset 5
 528               		.cfi_offset 28, -4
 529 01f4 DF93      		push r29
 530               	.LCFI14:
 531               		.cfi_def_cfa_offset 6
 532               		.cfi_offset 29, -5
 533 01f6 CDB7      		in r28,__SP_L__
 534 01f8 DEB7      		in r29,__SP_H__
 535               	.LCFI15:
 536               		.cfi_def_cfa_register 28
 537 01fa 6097      		sbiw r28,16
 538               	.LCFI16:
 539               		.cfi_def_cfa_offset 22
 540 01fc 0FB6      		in __tmp_reg__,__SREG__
 541 01fe F894      		cli
 542 0200 DEBF      		out __SP_H__,r29
 543 0202 0FBE      		out __SREG__,__tmp_reg__
 544 0204 CDBF      		out __SP_L__,r28
 545               	/* prologue: function */
 546               	/* frame size = 16 */
 547               	/* stack size = 20 */
 548               	.L__stack_usage = 20
 549 0206 8C01      		movw r16,r24
 550 0208 CB01      		movw r24,r22
 551               	.LVL36:
  89:LCD.c         **** 	// TODO: implement digits
  90:LCD.c         **** 	char string[16];
  91:LCD.c         **** 	itoa(number,string, format);
 552               		.loc 1 91 0
 553 020a 50E0      		ldi r21,0
 554               	.LBB31:
 555               	.LBB32:
 556               		.file 3 "/usr/avr/include/stdlib.h"
   1:/usr/avr/include/stdlib.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/stdlib.h ****    Copyright (c) 2004,2007 Joerg Wunsch
   3:/usr/avr/include/stdlib.h **** 
   4:/usr/avr/include/stdlib.h ****    Portions of documentation Copyright (c) 1990, 1991, 1993, 1994
   5:/usr/avr/include/stdlib.h ****    The Regents of the University of California.
   6:/usr/avr/include/stdlib.h **** 
   7:/usr/avr/include/stdlib.h ****    All rights reserved.
   8:/usr/avr/include/stdlib.h **** 
   9:/usr/avr/include/stdlib.h ****    Redistribution and use in source and binary forms, with or without
  10:/usr/avr/include/stdlib.h ****    modification, are permitted provided that the following conditions are met:
  11:/usr/avr/include/stdlib.h **** 
  12:/usr/avr/include/stdlib.h ****    * Redistributions of source code must retain the above copyright
  13:/usr/avr/include/stdlib.h ****      notice, this list of conditions and the following disclaimer.
  14:/usr/avr/include/stdlib.h **** 
  15:/usr/avr/include/stdlib.h ****    * Redistributions in binary form must reproduce the above copyright
  16:/usr/avr/include/stdlib.h ****      notice, this list of conditions and the following disclaimer in
  17:/usr/avr/include/stdlib.h ****      the documentation and/or other materials provided with the
  18:/usr/avr/include/stdlib.h ****      distribution.
  19:/usr/avr/include/stdlib.h **** 
  20:/usr/avr/include/stdlib.h ****    * Neither the name of the copyright holders nor the names of
  21:/usr/avr/include/stdlib.h ****      contributors may be used to endorse or promote products derived
  22:/usr/avr/include/stdlib.h ****      from this software without specific prior written permission.
  23:/usr/avr/include/stdlib.h **** 
  24:/usr/avr/include/stdlib.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  25:/usr/avr/include/stdlib.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  26:/usr/avr/include/stdlib.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  27:/usr/avr/include/stdlib.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  28:/usr/avr/include/stdlib.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  29:/usr/avr/include/stdlib.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  30:/usr/avr/include/stdlib.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  31:/usr/avr/include/stdlib.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  32:/usr/avr/include/stdlib.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  33:/usr/avr/include/stdlib.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  34:/usr/avr/include/stdlib.h ****   POSSIBILITY OF SUCH DAMAGE.
  35:/usr/avr/include/stdlib.h **** 
  36:/usr/avr/include/stdlib.h ****   $Id: stdlib.h 2443 2014-08-11 21:50:59Z joerg_wunsch $
  37:/usr/avr/include/stdlib.h **** */
  38:/usr/avr/include/stdlib.h **** 
  39:/usr/avr/include/stdlib.h **** #ifndef _STDLIB_H_
  40:/usr/avr/include/stdlib.h **** #define	_STDLIB_H_ 1
  41:/usr/avr/include/stdlib.h **** 
  42:/usr/avr/include/stdlib.h **** #ifndef __ASSEMBLER__
  43:/usr/avr/include/stdlib.h **** 
  44:/usr/avr/include/stdlib.h **** #define __need_NULL
  45:/usr/avr/include/stdlib.h **** #define __need_size_t
  46:/usr/avr/include/stdlib.h **** #define __need_wchar_t
  47:/usr/avr/include/stdlib.h **** #include <stddef.h>
  48:/usr/avr/include/stdlib.h **** 
  49:/usr/avr/include/stdlib.h **** #ifndef __ptr_t
  50:/usr/avr/include/stdlib.h **** #define __ptr_t void *
  51:/usr/avr/include/stdlib.h **** #endif
  52:/usr/avr/include/stdlib.h **** 
  53:/usr/avr/include/stdlib.h **** #ifdef __cplusplus
  54:/usr/avr/include/stdlib.h **** extern "C" {
  55:/usr/avr/include/stdlib.h **** #endif
  56:/usr/avr/include/stdlib.h **** 
  57:/usr/avr/include/stdlib.h **** /** \file */
  58:/usr/avr/include/stdlib.h **** 
  59:/usr/avr/include/stdlib.h **** /** \defgroup avr_stdlib <stdlib.h>: General utilities
  60:/usr/avr/include/stdlib.h ****     \code #include <stdlib.h> \endcode
  61:/usr/avr/include/stdlib.h **** 
  62:/usr/avr/include/stdlib.h ****     This file declares some basic C macros and functions as
  63:/usr/avr/include/stdlib.h ****     defined by the ISO standard, plus some AVR-specific extensions.
  64:/usr/avr/include/stdlib.h **** */
  65:/usr/avr/include/stdlib.h **** 
  66:/usr/avr/include/stdlib.h **** /*@{*/
  67:/usr/avr/include/stdlib.h **** /** Result type for function div(). */
  68:/usr/avr/include/stdlib.h **** typedef struct {
  69:/usr/avr/include/stdlib.h **** 	int quot;                   /**< The Quotient. */
  70:/usr/avr/include/stdlib.h **** 	int rem;                    /**< The Remainder. */
  71:/usr/avr/include/stdlib.h **** } div_t;
  72:/usr/avr/include/stdlib.h **** 
  73:/usr/avr/include/stdlib.h **** /** Result type for function ldiv(). */
  74:/usr/avr/include/stdlib.h **** typedef struct {
  75:/usr/avr/include/stdlib.h **** 	long quot;                  /**< The Quotient. */
  76:/usr/avr/include/stdlib.h **** 	long rem;                   /**< The Remainder. */
  77:/usr/avr/include/stdlib.h **** } ldiv_t;
  78:/usr/avr/include/stdlib.h **** 
  79:/usr/avr/include/stdlib.h **** /** Comparision function type for qsort(), just for convenience. */
  80:/usr/avr/include/stdlib.h **** typedef int (*__compar_fn_t)(const void *, const void *);
  81:/usr/avr/include/stdlib.h **** 
  82:/usr/avr/include/stdlib.h **** #ifndef __DOXYGEN__
  83:/usr/avr/include/stdlib.h **** 
  84:/usr/avr/include/stdlib.h **** #ifndef __ATTR_CONST__
  85:/usr/avr/include/stdlib.h **** # define __ATTR_CONST__ __attribute__((__const__))
  86:/usr/avr/include/stdlib.h **** #endif
  87:/usr/avr/include/stdlib.h **** 
  88:/usr/avr/include/stdlib.h **** #ifndef __ATTR_MALLOC__
  89:/usr/avr/include/stdlib.h **** # define __ATTR_MALLOC__ __attribute__((__malloc__))
  90:/usr/avr/include/stdlib.h **** #endif
  91:/usr/avr/include/stdlib.h **** 
  92:/usr/avr/include/stdlib.h **** #ifndef __ATTR_NORETURN__
  93:/usr/avr/include/stdlib.h **** # define __ATTR_NORETURN__ __attribute__((__noreturn__))
  94:/usr/avr/include/stdlib.h **** #endif
  95:/usr/avr/include/stdlib.h **** 
  96:/usr/avr/include/stdlib.h **** #ifndef __ATTR_PURE__
  97:/usr/avr/include/stdlib.h **** # define __ATTR_PURE__ __attribute__((__pure__))
  98:/usr/avr/include/stdlib.h **** #endif
  99:/usr/avr/include/stdlib.h **** 
 100:/usr/avr/include/stdlib.h **** #ifndef	__ATTR_GNU_INLINE__
 101:/usr/avr/include/stdlib.h **** # ifdef  __GNUC_STDC_INLINE__
 102:/usr/avr/include/stdlib.h **** #  define __ATTR_GNU_INLINE__   __attribute__((__gnu_inline__))
 103:/usr/avr/include/stdlib.h **** # else
 104:/usr/avr/include/stdlib.h **** #  define __ATTR_GNU_INLINE__
 105:/usr/avr/include/stdlib.h **** # endif
 106:/usr/avr/include/stdlib.h **** #endif
 107:/usr/avr/include/stdlib.h **** 
 108:/usr/avr/include/stdlib.h **** #endif
 109:/usr/avr/include/stdlib.h **** 
 110:/usr/avr/include/stdlib.h **** /** The abort() function causes abnormal program termination to occur.
 111:/usr/avr/include/stdlib.h ****     This realization disables interrupts and jumps to _exit() function
 112:/usr/avr/include/stdlib.h ****     with argument equal to 1. In the limited AVR environment, execution is
 113:/usr/avr/include/stdlib.h ****     effectively halted by entering an infinite loop. */
 114:/usr/avr/include/stdlib.h **** extern void abort(void) __ATTR_NORETURN__;
 115:/usr/avr/include/stdlib.h **** 
 116:/usr/avr/include/stdlib.h **** /** The abs() function computes the absolute value of the integer \c i.
 117:/usr/avr/include/stdlib.h ****    \note The abs() and labs() functions are builtins of gcc.
 118:/usr/avr/include/stdlib.h **** */
 119:/usr/avr/include/stdlib.h **** extern int abs(int __i) __ATTR_CONST__;
 120:/usr/avr/include/stdlib.h **** #ifndef __DOXYGEN__
 121:/usr/avr/include/stdlib.h **** #define	abs(__i) __builtin_abs(__i)
 122:/usr/avr/include/stdlib.h **** #endif
 123:/usr/avr/include/stdlib.h **** 
 124:/usr/avr/include/stdlib.h **** /** The labs() function computes the absolute value of the long integer
 125:/usr/avr/include/stdlib.h ****     \c i.
 126:/usr/avr/include/stdlib.h ****    \note The abs() and labs() functions are builtins of gcc.
 127:/usr/avr/include/stdlib.h **** */
 128:/usr/avr/include/stdlib.h **** extern long labs(long __i) __ATTR_CONST__;
 129:/usr/avr/include/stdlib.h **** #ifndef __DOXYGEN__
 130:/usr/avr/include/stdlib.h **** #define labs(__i) __builtin_labs(__i)
 131:/usr/avr/include/stdlib.h **** #endif
 132:/usr/avr/include/stdlib.h **** 
 133:/usr/avr/include/stdlib.h **** /**
 134:/usr/avr/include/stdlib.h ****      The bsearch() function searches an array of \c nmemb objects, the
 135:/usr/avr/include/stdlib.h ****      initial member of which is pointed to by \c base, for a member
 136:/usr/avr/include/stdlib.h ****      that matches the object pointed to by \c key.  The size of each
 137:/usr/avr/include/stdlib.h ****      member of the array is specified by \c size.
 138:/usr/avr/include/stdlib.h **** 
 139:/usr/avr/include/stdlib.h ****      The contents of the array should be in ascending sorted order
 140:/usr/avr/include/stdlib.h ****      according to the comparison function referenced by \c compar.
 141:/usr/avr/include/stdlib.h ****      The \c compar routine is expected to have two arguments which
 142:/usr/avr/include/stdlib.h ****      point to the key object and to an array member, in that order,
 143:/usr/avr/include/stdlib.h ****      and should return an integer less than, equal to, or greater than
 144:/usr/avr/include/stdlib.h ****      zero if the key object is found, respectively, to be less than,
 145:/usr/avr/include/stdlib.h ****      to match, or be greater than the array member.
 146:/usr/avr/include/stdlib.h **** 
 147:/usr/avr/include/stdlib.h ****      The bsearch() function returns a pointer to a matching member of
 148:/usr/avr/include/stdlib.h ****      the array, or a null pointer if no match is found.  If two
 149:/usr/avr/include/stdlib.h ****      members compare as equal, which member is matched is unspecified.
 150:/usr/avr/include/stdlib.h **** */
 151:/usr/avr/include/stdlib.h **** extern void *bsearch(const void *__key, const void *__base, size_t __nmemb,
 152:/usr/avr/include/stdlib.h **** 		     size_t __size, int (*__compar)(const void *, const void *));
 153:/usr/avr/include/stdlib.h **** 
 154:/usr/avr/include/stdlib.h **** /* __divmodhi4 and __divmodsi4 from libgcc.a */
 155:/usr/avr/include/stdlib.h **** /**
 156:/usr/avr/include/stdlib.h ****      The div() function computes the value \c num/denom and returns
 157:/usr/avr/include/stdlib.h ****      the quotient and remainder in a structure named \c div_t that
 158:/usr/avr/include/stdlib.h ****      contains two int members named \c quot and \c rem.
 159:/usr/avr/include/stdlib.h **** */
 160:/usr/avr/include/stdlib.h **** extern div_t div(int __num, int __denom) __asm__("__divmodhi4") __ATTR_CONST__;
 161:/usr/avr/include/stdlib.h **** /**
 162:/usr/avr/include/stdlib.h ****      The ldiv() function computes the value \c num/denom and returns
 163:/usr/avr/include/stdlib.h ****      the quotient and remainder in a structure named \c ldiv_t that
 164:/usr/avr/include/stdlib.h ****      contains two long integer members named \c quot and \c rem.
 165:/usr/avr/include/stdlib.h **** */
 166:/usr/avr/include/stdlib.h **** extern ldiv_t ldiv(long __num, long __denom) __asm__("__divmodsi4") __ATTR_CONST__;
 167:/usr/avr/include/stdlib.h **** 
 168:/usr/avr/include/stdlib.h **** /**
 169:/usr/avr/include/stdlib.h ****      The qsort() function is a modified partition-exchange sort, or
 170:/usr/avr/include/stdlib.h ****      quicksort.
 171:/usr/avr/include/stdlib.h **** 
 172:/usr/avr/include/stdlib.h ****      The qsort() function sorts an array of \c nmemb objects, the
 173:/usr/avr/include/stdlib.h ****      initial member of which is pointed to by \c base.  The size of
 174:/usr/avr/include/stdlib.h ****      each object is specified by \c size.  The contents of the array
 175:/usr/avr/include/stdlib.h ****      base are sorted in ascending order according to a comparison
 176:/usr/avr/include/stdlib.h ****      function pointed to by \c compar, which requires two arguments
 177:/usr/avr/include/stdlib.h ****      pointing to the objects being compared.
 178:/usr/avr/include/stdlib.h **** 
 179:/usr/avr/include/stdlib.h ****      The comparison function must return an integer less than, equal
 180:/usr/avr/include/stdlib.h ****      to, or greater than zero if the first argument is considered to
 181:/usr/avr/include/stdlib.h ****      be respectively less than, equal to, or greater than the second.
 182:/usr/avr/include/stdlib.h **** */
 183:/usr/avr/include/stdlib.h **** extern void qsort(void *__base, size_t __nmemb, size_t __size,
 184:/usr/avr/include/stdlib.h **** 		  __compar_fn_t __compar);
 185:/usr/avr/include/stdlib.h **** 
 186:/usr/avr/include/stdlib.h **** /**
 187:/usr/avr/include/stdlib.h ****     The strtol() function converts the string in \c nptr to a long
 188:/usr/avr/include/stdlib.h ****     value.  The conversion is done according to the given base, which
 189:/usr/avr/include/stdlib.h ****     must be between 2 and 36 inclusive, or be the special value 0.
 190:/usr/avr/include/stdlib.h **** 
 191:/usr/avr/include/stdlib.h ****     The string may begin with an arbitrary amount of white space (as
 192:/usr/avr/include/stdlib.h ****     determined by isspace()) followed by a single optional \c '+' or \c '-'
 193:/usr/avr/include/stdlib.h ****     sign.  If \c base is zero or 16, the string may then include a
 194:/usr/avr/include/stdlib.h ****     \c "0x" prefix, and the number will be read in base 16; otherwise,
 195:/usr/avr/include/stdlib.h ****     a zero base is taken as 10 (decimal) unless the next character is
 196:/usr/avr/include/stdlib.h ****     \c '0', in which case it is taken as 8 (octal).
 197:/usr/avr/include/stdlib.h **** 
 198:/usr/avr/include/stdlib.h ****     The remainder of the string is converted to a long value in the
 199:/usr/avr/include/stdlib.h ****     obvious manner, stopping at the first character which is not a
 200:/usr/avr/include/stdlib.h ****     valid digit in the given base.  (In bases above 10, the letter \c 'A'
 201:/usr/avr/include/stdlib.h ****     in either upper or lower case represents 10, \c 'B' represents 11,
 202:/usr/avr/include/stdlib.h ****     and so forth, with \c 'Z' representing 35.)
 203:/usr/avr/include/stdlib.h **** 
 204:/usr/avr/include/stdlib.h ****     If \c endptr is not NULL, strtol() stores the address of the first
 205:/usr/avr/include/stdlib.h ****     invalid character in \c *endptr.  If there were no digits at all,
 206:/usr/avr/include/stdlib.h ****     however, strtol() stores the original value of \c nptr in \c
 207:/usr/avr/include/stdlib.h ****     *endptr.  (Thus, if \c *nptr is not \c '\\0' but \c **endptr is \c '\\0'
 208:/usr/avr/include/stdlib.h ****     on return, the entire string was valid.)
 209:/usr/avr/include/stdlib.h **** 
 210:/usr/avr/include/stdlib.h ****     The strtol() function returns the result of the conversion, unless
 211:/usr/avr/include/stdlib.h ****     the value would underflow or overflow.  If no conversion could be
 212:/usr/avr/include/stdlib.h ****     performed, 0 is returned.  If an overflow or underflow occurs, \c
 213:/usr/avr/include/stdlib.h ****     errno is set to \ref avr_errno "ERANGE" and the function return value
 214:/usr/avr/include/stdlib.h ****     is clamped to \c LONG_MIN or \c LONG_MAX, respectively.
 215:/usr/avr/include/stdlib.h **** */
 216:/usr/avr/include/stdlib.h **** extern long strtol(const char *__nptr, char **__endptr, int __base);
 217:/usr/avr/include/stdlib.h **** 
 218:/usr/avr/include/stdlib.h **** /**
 219:/usr/avr/include/stdlib.h ****     The strtoul() function converts the string in \c nptr to an
 220:/usr/avr/include/stdlib.h ****     unsigned long value.  The conversion is done according to the
 221:/usr/avr/include/stdlib.h ****     given base, which must be between 2 and 36 inclusive, or be the
 222:/usr/avr/include/stdlib.h ****     special value 0.
 223:/usr/avr/include/stdlib.h **** 
 224:/usr/avr/include/stdlib.h ****     The string may begin with an arbitrary amount of white space (as
 225:/usr/avr/include/stdlib.h ****     determined by isspace()) followed by a single optional \c '+' or \c '-'
 226:/usr/avr/include/stdlib.h ****     sign.  If \c base is zero or 16, the string may then include a
 227:/usr/avr/include/stdlib.h ****     \c "0x" prefix, and the number will be read in base 16; otherwise,
 228:/usr/avr/include/stdlib.h ****     a zero base is taken as 10 (decimal) unless the next character is
 229:/usr/avr/include/stdlib.h ****     \c '0', in which case it is taken as 8 (octal).
 230:/usr/avr/include/stdlib.h **** 
 231:/usr/avr/include/stdlib.h ****     The remainder of the string is converted to an unsigned long value
 232:/usr/avr/include/stdlib.h ****     in the obvious manner, stopping at the first character which is
 233:/usr/avr/include/stdlib.h ****     not a valid digit in the given base.  (In bases above 10, the
 234:/usr/avr/include/stdlib.h ****     letter \c 'A' in either upper or lower case represents 10, \c 'B'
 235:/usr/avr/include/stdlib.h ****     represents 11, and so forth, with \c 'Z' representing 35.)
 236:/usr/avr/include/stdlib.h **** 
 237:/usr/avr/include/stdlib.h ****     If \c endptr is not NULL, strtoul() stores the address of the first
 238:/usr/avr/include/stdlib.h ****     invalid character in \c *endptr.  If there were no digits at all,
 239:/usr/avr/include/stdlib.h ****     however, strtoul() stores the original value of \c nptr in \c
 240:/usr/avr/include/stdlib.h ****     *endptr.  (Thus, if \c *nptr is not \c '\\0' but \c **endptr is \c '\\0'
 241:/usr/avr/include/stdlib.h ****     on return, the entire string was valid.)
 242:/usr/avr/include/stdlib.h **** 
 243:/usr/avr/include/stdlib.h ****     The strtoul() function return either the result of the conversion
 244:/usr/avr/include/stdlib.h ****     or, if there was a leading minus sign, the negation of the result
 245:/usr/avr/include/stdlib.h ****     of the conversion, unless the original (non-negated) value would
 246:/usr/avr/include/stdlib.h ****     overflow; in the latter case, strtoul() returns ULONG_MAX, and \c
 247:/usr/avr/include/stdlib.h ****     errno is set to \ref avr_errno "ERANGE".  If no conversion could 
 248:/usr/avr/include/stdlib.h ****     be performed, 0 is returned.
 249:/usr/avr/include/stdlib.h **** */
 250:/usr/avr/include/stdlib.h **** extern unsigned long strtoul(const char *__nptr, char **__endptr, int __base);
 251:/usr/avr/include/stdlib.h **** 
 252:/usr/avr/include/stdlib.h **** /**
 253:/usr/avr/include/stdlib.h ****     The atol() function converts the initial portion of the string
 254:/usr/avr/include/stdlib.h ****     pointed to by \p s to long integer representation. In contrast to
 255:/usr/avr/include/stdlib.h **** 
 256:/usr/avr/include/stdlib.h ****         \code strtol(s, (char **)NULL, 10); \endcode
 257:/usr/avr/include/stdlib.h **** 
 258:/usr/avr/include/stdlib.h ****     this function does not detect overflow (\c errno is not changed and
 259:/usr/avr/include/stdlib.h ****     the result value is not predictable), uses smaller memory (flash and
 260:/usr/avr/include/stdlib.h ****     stack) and works more quickly.
 261:/usr/avr/include/stdlib.h **** */
 262:/usr/avr/include/stdlib.h **** extern long atol(const char *__s) __ATTR_PURE__;
 263:/usr/avr/include/stdlib.h **** 
 264:/usr/avr/include/stdlib.h **** /**
 265:/usr/avr/include/stdlib.h ****     The atoi() function converts the initial portion of the string
 266:/usr/avr/include/stdlib.h ****     pointed to by \p s to integer representation. In contrast to
 267:/usr/avr/include/stdlib.h **** 
 268:/usr/avr/include/stdlib.h ****         \code (int)strtol(s, (char **)NULL, 10); \endcode
 269:/usr/avr/include/stdlib.h **** 
 270:/usr/avr/include/stdlib.h ****     this function does not detect overflow (\c errno is not changed and
 271:/usr/avr/include/stdlib.h ****     the result value is not predictable), uses smaller memory (flash and
 272:/usr/avr/include/stdlib.h ****     stack) and works more quickly.
 273:/usr/avr/include/stdlib.h **** */
 274:/usr/avr/include/stdlib.h **** extern int atoi(const char *__s) __ATTR_PURE__;
 275:/usr/avr/include/stdlib.h **** 
 276:/usr/avr/include/stdlib.h **** /**
 277:/usr/avr/include/stdlib.h ****    The exit() function terminates the application.  Since there is no
 278:/usr/avr/include/stdlib.h ****    environment to return to, \c status is ignored, and code execution
 279:/usr/avr/include/stdlib.h ****    will eventually reach an infinite loop, thereby effectively halting
 280:/usr/avr/include/stdlib.h ****    all code processing.  Before entering the infinite loop, interrupts
 281:/usr/avr/include/stdlib.h ****    are globally disabled.
 282:/usr/avr/include/stdlib.h **** 
 283:/usr/avr/include/stdlib.h ****    In a C++ context, global destructors will be called before halting
 284:/usr/avr/include/stdlib.h ****    execution.
 285:/usr/avr/include/stdlib.h **** */
 286:/usr/avr/include/stdlib.h **** extern void exit(int __status) __ATTR_NORETURN__;
 287:/usr/avr/include/stdlib.h **** 
 288:/usr/avr/include/stdlib.h **** /**
 289:/usr/avr/include/stdlib.h ****    The malloc() function allocates \c size bytes of memory.
 290:/usr/avr/include/stdlib.h ****    If malloc() fails, a NULL pointer is returned.
 291:/usr/avr/include/stdlib.h **** 
 292:/usr/avr/include/stdlib.h ****    Note that malloc() does \e not initialize the returned memory to
 293:/usr/avr/include/stdlib.h ****    zero bytes.
 294:/usr/avr/include/stdlib.h **** 
 295:/usr/avr/include/stdlib.h ****    See the chapter about \ref malloc "malloc() usage" for implementation
 296:/usr/avr/include/stdlib.h ****    details.
 297:/usr/avr/include/stdlib.h **** */
 298:/usr/avr/include/stdlib.h **** extern void *malloc(size_t __size) __ATTR_MALLOC__;
 299:/usr/avr/include/stdlib.h **** 
 300:/usr/avr/include/stdlib.h **** /**
 301:/usr/avr/include/stdlib.h ****    The free() function causes the allocated memory referenced by \c
 302:/usr/avr/include/stdlib.h ****    ptr to be made available for future allocations.  If \c ptr is
 303:/usr/avr/include/stdlib.h ****    NULL, no action occurs.
 304:/usr/avr/include/stdlib.h **** */
 305:/usr/avr/include/stdlib.h **** extern void free(void *__ptr);
 306:/usr/avr/include/stdlib.h **** 
 307:/usr/avr/include/stdlib.h **** /**
 308:/usr/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 309:/usr/avr/include/stdlib.h **** */
 310:/usr/avr/include/stdlib.h **** extern size_t __malloc_margin;
 311:/usr/avr/include/stdlib.h **** 
 312:/usr/avr/include/stdlib.h **** /**
 313:/usr/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 314:/usr/avr/include/stdlib.h **** */
 315:/usr/avr/include/stdlib.h **** extern char *__malloc_heap_start;
 316:/usr/avr/include/stdlib.h **** 
 317:/usr/avr/include/stdlib.h **** /**
 318:/usr/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 319:/usr/avr/include/stdlib.h **** */
 320:/usr/avr/include/stdlib.h **** extern char *__malloc_heap_end;
 321:/usr/avr/include/stdlib.h **** 
 322:/usr/avr/include/stdlib.h **** /**
 323:/usr/avr/include/stdlib.h ****    Allocate \c nele elements of \c size each.  Identical to calling
 324:/usr/avr/include/stdlib.h ****    \c malloc() using <tt>nele * size</tt> as argument, except the
 325:/usr/avr/include/stdlib.h ****    allocated memory will be cleared to zero.
 326:/usr/avr/include/stdlib.h **** */
 327:/usr/avr/include/stdlib.h **** extern void *calloc(size_t __nele, size_t __size) __ATTR_MALLOC__;
 328:/usr/avr/include/stdlib.h **** 
 329:/usr/avr/include/stdlib.h **** /**
 330:/usr/avr/include/stdlib.h ****    The realloc() function tries to change the size of the region
 331:/usr/avr/include/stdlib.h ****    allocated at \c ptr to the new \c size value.  It returns a
 332:/usr/avr/include/stdlib.h ****    pointer to the new region.  The returned pointer might be the
 333:/usr/avr/include/stdlib.h ****    same as the old pointer, or a pointer to a completely different
 334:/usr/avr/include/stdlib.h ****    region.
 335:/usr/avr/include/stdlib.h **** 
 336:/usr/avr/include/stdlib.h ****    The contents of the returned region up to either the old or the new
 337:/usr/avr/include/stdlib.h ****    size value (whatever is less) will be identical to the contents of
 338:/usr/avr/include/stdlib.h ****    the old region, even in case a new region had to be allocated.
 339:/usr/avr/include/stdlib.h **** 
 340:/usr/avr/include/stdlib.h ****    It is acceptable to pass \c ptr as NULL, in which case realloc()
 341:/usr/avr/include/stdlib.h ****    will behave identical to malloc().
 342:/usr/avr/include/stdlib.h **** 
 343:/usr/avr/include/stdlib.h ****    If the new memory cannot be allocated, realloc() returns NULL, and
 344:/usr/avr/include/stdlib.h ****    the region at \c ptr will not be changed.
 345:/usr/avr/include/stdlib.h **** */
 346:/usr/avr/include/stdlib.h **** extern void *realloc(void *__ptr, size_t __size) __ATTR_MALLOC__;
 347:/usr/avr/include/stdlib.h **** 
 348:/usr/avr/include/stdlib.h **** extern double strtod(const char *__nptr, char **__endptr);
 349:/usr/avr/include/stdlib.h **** 
 350:/usr/avr/include/stdlib.h **** extern double atof(const char *__nptr);
 351:/usr/avr/include/stdlib.h **** 
 352:/usr/avr/include/stdlib.h **** /** Highest number that can be generated by rand(). */
 353:/usr/avr/include/stdlib.h **** #define	RAND_MAX 0x7FFF
 354:/usr/avr/include/stdlib.h **** 
 355:/usr/avr/include/stdlib.h **** /**
 356:/usr/avr/include/stdlib.h ****      The rand() function computes a sequence of pseudo-random integers in the
 357:/usr/avr/include/stdlib.h ****      range of 0 to \c RAND_MAX (as defined by the header file <stdlib.h>).
 358:/usr/avr/include/stdlib.h **** 
 359:/usr/avr/include/stdlib.h ****      The srand() function sets its argument \c seed as the seed for a new
 360:/usr/avr/include/stdlib.h ****      sequence of pseudo-random numbers to be returned by rand().  These
 361:/usr/avr/include/stdlib.h ****      sequences are repeatable by calling srand() with the same seed value.
 362:/usr/avr/include/stdlib.h **** 
 363:/usr/avr/include/stdlib.h ****      If no seed value is provided, the functions are automatically seeded with
 364:/usr/avr/include/stdlib.h ****      a value of 1.
 365:/usr/avr/include/stdlib.h **** 
 366:/usr/avr/include/stdlib.h ****      In compliance with the C standard, these functions operate on
 367:/usr/avr/include/stdlib.h ****      \c int arguments.  Since the underlying algorithm already uses
 368:/usr/avr/include/stdlib.h ****      32-bit calculations, this causes a loss of precision.  See
 369:/usr/avr/include/stdlib.h ****      \c random() for an alternate set of functions that retains full
 370:/usr/avr/include/stdlib.h ****      32-bit precision.
 371:/usr/avr/include/stdlib.h **** */
 372:/usr/avr/include/stdlib.h **** extern int rand(void);
 373:/usr/avr/include/stdlib.h **** /**
 374:/usr/avr/include/stdlib.h ****    Pseudo-random number generator seeding; see rand().
 375:/usr/avr/include/stdlib.h **** */
 376:/usr/avr/include/stdlib.h **** extern void srand(unsigned int __seed);
 377:/usr/avr/include/stdlib.h **** 
 378:/usr/avr/include/stdlib.h **** /**
 379:/usr/avr/include/stdlib.h ****    Variant of rand() that stores the context in the user-supplied
 380:/usr/avr/include/stdlib.h ****    variable located at \c ctx instead of a static library variable
 381:/usr/avr/include/stdlib.h ****    so the function becomes re-entrant.
 382:/usr/avr/include/stdlib.h **** */
 383:/usr/avr/include/stdlib.h **** extern int rand_r(unsigned long *__ctx);
 384:/usr/avr/include/stdlib.h **** /*@}*/
 385:/usr/avr/include/stdlib.h **** 
 386:/usr/avr/include/stdlib.h **** /*@{*/
 387:/usr/avr/include/stdlib.h **** /** \name Non-standard (i.e. non-ISO C) functions.
 388:/usr/avr/include/stdlib.h ****  \ingroup avr_stdlib
 389:/usr/avr/include/stdlib.h **** */
 390:/usr/avr/include/stdlib.h **** /**
 391:/usr/avr/include/stdlib.h ****    \brief Convert an integer to a string.
 392:/usr/avr/include/stdlib.h **** 
 393:/usr/avr/include/stdlib.h ****    The function itoa() converts the integer value from \c val into an
 394:/usr/avr/include/stdlib.h ****    ASCII representation that will be stored under \c s.  The caller
 395:/usr/avr/include/stdlib.h ****    is responsible for providing sufficient storage in \c s.
 396:/usr/avr/include/stdlib.h **** 
 397:/usr/avr/include/stdlib.h ****    \note The minimal size of the buffer \c s depends on the choice of
 398:/usr/avr/include/stdlib.h ****    radix. For example, if the radix is 2 (binary), you need to supply a buffer
 399:/usr/avr/include/stdlib.h ****    with a minimal length of 8 * sizeof (int) + 1 characters, i.e. one
 400:/usr/avr/include/stdlib.h ****    character for each bit plus one for the string terminator. Using a larger
 401:/usr/avr/include/stdlib.h ****    radix will require a smaller minimal buffer size.
 402:/usr/avr/include/stdlib.h **** 
 403:/usr/avr/include/stdlib.h ****    \warning If the buffer is too small, you risk a buffer overflow.
 404:/usr/avr/include/stdlib.h **** 
 405:/usr/avr/include/stdlib.h ****    Conversion is done using the \c radix as base, which may be a
 406:/usr/avr/include/stdlib.h ****    number between 2 (binary conversion) and up to 36.  If \c radix
 407:/usr/avr/include/stdlib.h ****    is greater than 10, the next digit after \c '9' will be the letter
 408:/usr/avr/include/stdlib.h ****    \c 'a'.
 409:/usr/avr/include/stdlib.h ****     
 410:/usr/avr/include/stdlib.h ****     If radix is 10 and val is negative, a minus sign will be prepended.
 411:/usr/avr/include/stdlib.h **** 
 412:/usr/avr/include/stdlib.h ****    The itoa() function returns the pointer passed as \c s.
 413:/usr/avr/include/stdlib.h **** */
 414:/usr/avr/include/stdlib.h **** #ifdef  __DOXYGEN__
 415:/usr/avr/include/stdlib.h **** extern char *itoa(int val, char *s, int radix);
 416:/usr/avr/include/stdlib.h **** #else
 417:/usr/avr/include/stdlib.h **** extern __inline__ __ATTR_GNU_INLINE__
 418:/usr/avr/include/stdlib.h **** char *itoa (int __val, char *__s, int __radix)
 419:/usr/avr/include/stdlib.h **** {
 420:/usr/avr/include/stdlib.h ****     if (!__builtin_constant_p (__radix)) {
 421:/usr/avr/include/stdlib.h **** 	extern char *__itoa (int, char *, int);
 422:/usr/avr/include/stdlib.h **** 	return __itoa (__val, __s, __radix);
 557               		.loc 3 422 0
 558 020c BE01      		movw r22,r28
 559               	.LVL37:
 560 020e 6F5F      		subi r22,-1
 561 0210 7F4F      		sbci r23,-1
 562 0212 00D0      		rcall __itoa
 563               	.LVL38:
 564               	.LBE32:
 565               	.LBE31:
  92:LCD.c         **** 	LCD_STRING(device, string);
 566               		.loc 1 92 0
 567 0214 BE01      		movw r22,r28
 568 0216 6F5F      		subi r22,-1
 569 0218 7F4F      		sbci r23,-1
 570 021a C801      		movw r24,r16
 571 021c 00D0      		rcall LCD_STRING
 572               	.LVL39:
 573               	/* epilogue start */
  93:LCD.c         **** }
 574               		.loc 1 93 0
 575 021e 6096      		adiw r28,16
 576 0220 0FB6      		in __tmp_reg__,__SREG__
 577 0222 F894      		cli
 578 0224 DEBF      		out __SP_H__,r29
 579 0226 0FBE      		out __SREG__,__tmp_reg__
 580 0228 CDBF      		out __SP_L__,r28
 581 022a DF91      		pop r29
 582 022c CF91      		pop r28
 583 022e 1F91      		pop r17
 584 0230 0F91      		pop r16
 585               	.LVL40:
 586 0232 0895      		ret
 587               		.cfi_endproc
 588               	.LFE18:
 590               	.global	LCD_INT
 592               	LCD_INT:
 593               	.LFB17:
  83:LCD.c         **** 	LCD_INTX(device, number, DEC, 0);
 594               		.loc 1 83 0
 595               		.cfi_startproc
 596               	.LVL41:
 597               	/* prologue: function */
 598               	/* frame size = 0 */
 599               	/* stack size = 0 */
 600               	.L__stack_usage = 0
  84:LCD.c         **** }
 601               		.loc 1 84 0
 602 0234 20E0      		ldi r18,0
 603 0236 4AE0      		ldi r20,lo8(10)
 604 0238 00C0      		rjmp LCD_INTX
 605               	.LVL42:
 606               		.cfi_endproc
 607               	.LFE17:
 609               	.global	LCD_FLOATX
 611               	LCD_FLOATX:
 612               	.LFB20:
  94:LCD.c         **** 
  95:LCD.c         **** 
  96:LCD.c         **** void LCD_FLOAT(type_LCD *device, float number)
  97:LCD.c         **** {
  98:LCD.c         **** 	LCD_FLOATX(device, number, 0, 2);
  99:LCD.c         **** }
 100:LCD.c         **** 
 101:LCD.c         **** void LCD_FLOATX(type_LCD *device, float number, uint8_t digitsLeft, uint8_t digitsRight)
 102:LCD.c         **** {
 613               		.loc 1 102 0
 614               		.cfi_startproc
 615               	.LVL43:
 616 023a EF92      		push r14
 617               	.LCFI17:
 618               		.cfi_def_cfa_offset 3
 619               		.cfi_offset 14, -2
 620 023c FF92      		push r15
 621               	.LCFI18:
 622               		.cfi_def_cfa_offset 4
 623               		.cfi_offset 15, -3
 624 023e 0F93      		push r16
 625               	.LCFI19:
 626               		.cfi_def_cfa_offset 5
 627               		.cfi_offset 16, -4
 628 0240 1F93      		push r17
 629               	.LCFI20:
 630               		.cfi_def_cfa_offset 6
 631               		.cfi_offset 17, -5
 632 0242 CF93      		push r28
 633               	.LCFI21:
 634               		.cfi_def_cfa_offset 7
 635               		.cfi_offset 28, -6
 636 0244 DF93      		push r29
 637               	.LCFI22:
 638               		.cfi_def_cfa_offset 8
 639               		.cfi_offset 29, -7
 640 0246 CDB7      		in r28,__SP_L__
 641 0248 DEB7      		in r29,__SP_H__
 642               	.LCFI23:
 643               		.cfi_def_cfa_register 28
 644 024a 6097      		sbiw r28,16
 645               	.LCFI24:
 646               		.cfi_def_cfa_offset 24
 647 024c 0FB6      		in __tmp_reg__,__SREG__
 648 024e F894      		cli
 649 0250 DEBF      		out __SP_H__,r29
 650 0252 0FBE      		out __SREG__,__tmp_reg__
 651 0254 CDBF      		out __SP_L__,r28
 652               	/* prologue: function */
 653               	/* frame size = 16 */
 654               	/* stack size = 22 */
 655               	.L__stack_usage = 22
 656 0256 7C01      		movw r14,r24
 657 0258 CB01      		movw r24,r22
 658 025a BA01      		movw r22,r20
 659 025c 202F      		mov r18,r16
 660               	.LVL44:
 103:LCD.c         **** 	// TODO: implement digitsLeft
 104:LCD.c         **** 	char string[16];
 105:LCD.c         **** 	dtostrf(number,1,digitsRight,string);
 661               		.loc 1 105 0
 662 025e 8E01      		movw r16,r28
 663               	.LVL45:
 664 0260 0F5F      		subi r16,-1
 665 0262 1F4F      		sbci r17,-1
 666 0264 41E0      		ldi r20,lo8(1)
 667               	.LVL46:
 668 0266 00D0      		rcall dtostrf
 669               	.LVL47:
 106:LCD.c         **** 	LCD_STRING(device, string);
 670               		.loc 1 106 0
 671 0268 B801      		movw r22,r16
 672 026a C701      		movw r24,r14
 673 026c 00D0      		rcall LCD_STRING
 674               	.LVL48:
 675               	/* epilogue start */
 107:LCD.c         **** }
 676               		.loc 1 107 0
 677 026e 6096      		adiw r28,16
 678 0270 0FB6      		in __tmp_reg__,__SREG__
 679 0272 F894      		cli
 680 0274 DEBF      		out __SP_H__,r29
 681 0276 0FBE      		out __SREG__,__tmp_reg__
 682 0278 CDBF      		out __SP_L__,r28
 683 027a DF91      		pop r29
 684 027c CF91      		pop r28
 685 027e 1F91      		pop r17
 686 0280 0F91      		pop r16
 687 0282 FF90      		pop r15
 688 0284 EF90      		pop r14
 689               	.LVL49:
 690 0286 0895      		ret
 691               		.cfi_endproc
 692               	.LFE20:
 694               	.global	LCD_FLOAT
 696               	LCD_FLOAT:
 697               	.LFB19:
  97:LCD.c         **** 	LCD_FLOATX(device, number, 0, 2);
 698               		.loc 1 97 0
 699               		.cfi_startproc
 700               	.LVL50:
 701 0288 0F93      		push r16
 702               	.LCFI25:
 703               		.cfi_def_cfa_offset 3
 704               		.cfi_offset 16, -2
 705               	/* prologue: function */
 706               	/* frame size = 0 */
 707               	/* stack size = 1 */
 708               	.L__stack_usage = 1
  98:LCD.c         **** }
 709               		.loc 1 98 0
 710 028a 02E0      		ldi r16,lo8(2)
 711 028c 20E0      		ldi r18,0
 712 028e 00D0      		rcall LCD_FLOATX
 713               	.LVL51:
 714               	/* epilogue start */
  99:LCD.c         **** 
 715               		.loc 1 99 0
 716 0290 0F91      		pop r16
 717 0292 0895      		ret
 718               		.cfi_endproc
 719               	.LFE19:
 721               	.global	LCD_GENERATECHAR
 723               	LCD_GENERATECHAR:
 724               	.LFB21:
 108:LCD.c         **** 
 109:LCD.c         **** void LCD_GENERATECHAR(type_LCD *device, uint8_t code, uint8_t *data)
 110:LCD.c         **** {
 725               		.loc 1 110 0
 726               		.cfi_startproc
 727               	.LVL52:
 728 0294 CF92      		push r12
 729               	.LCFI26:
 730               		.cfi_def_cfa_offset 3
 731               		.cfi_offset 12, -2
 732 0296 DF92      		push r13
 733               	.LCFI27:
 734               		.cfi_def_cfa_offset 4
 735               		.cfi_offset 13, -3
 736 0298 EF92      		push r14
 737               	.LCFI28:
 738               		.cfi_def_cfa_offset 5
 739               		.cfi_offset 14, -4
 740 029a FF92      		push r15
 741               	.LCFI29:
 742               		.cfi_def_cfa_offset 6
 743               		.cfi_offset 15, -5
 744 029c 0F93      		push r16
 745               	.LCFI30:
 746               		.cfi_def_cfa_offset 7
 747               		.cfi_offset 16, -6
 748 029e 1F93      		push r17
 749               	.LCFI31:
 750               		.cfi_def_cfa_offset 8
 751               		.cfi_offset 17, -7
 752 02a0 CF93      		push r28
 753               	.LCFI32:
 754               		.cfi_def_cfa_offset 9
 755               		.cfi_offset 28, -8
 756 02a2 DF93      		push r29
 757               	.LCFI33:
 758               		.cfi_def_cfa_offset 10
 759               		.cfi_offset 29, -9
 760 02a4 1F92      		push __zero_reg__
 761               	.LCFI34:
 762               		.cfi_def_cfa_offset 11
 763 02a6 CDB7      		in r28,__SP_L__
 764 02a8 DEB7      		in r29,__SP_H__
 765               	.LCFI35:
 766               		.cfi_def_cfa_register 28
 767               	/* prologue: function */
 768               	/* frame size = 1 */
 769               	/* stack size = 9 */
 770               	.L__stack_usage = 9
 771 02aa 8C01      		movw r16,r24
 772 02ac F42E      		mov r15,r20
 111:LCD.c         **** 	LCD_WRITE(device, LCD_CMD, LCD_SET_CGADR|(code<<3));
 773               		.loc 1 111 0
 774 02ae 88E0      		ldi r24,lo8(8)
 775               	.LVL53:
 776 02b0 689F      		mul r22,r24
 777 02b2 B001      		movw r22,r0
 778 02b4 1124      		clr __zero_reg__
 779               	.LVL54:
 780 02b6 462F      		mov r20,r22
 781               	.LVL55:
 782 02b8 4064      		ori r20,lo8(64)
 783 02ba 61E0      		ldi r22,lo8(1)
 784 02bc C801      		movw r24,r16
 785 02be 5983      		std Y+1,r21
 786 02c0 00D0      		rcall LCD_WRITE
 787               	.LVL56:
 788 02c2 CF2C      		mov r12,r15
 789 02c4 5981      		ldd r21,Y+1
 790 02c6 D52E      		mov r13,r21
 791 02c8 7601      		movw r14,r12
 792 02ca E8E0      		ldi r30,8
 793 02cc EE0E      		add r14,r30
 794 02ce F11C      		adc r15,__zero_reg__
 795               	.LVL57:
 796               	.L36:
 797               	.LBB33:
 112:LCD.c         **** 	for (uint8_t i=0; i<8; i++)
 113:LCD.c         **** 	{
 114:LCD.c         **** 		LCD_WRITE(device, LCD_DATA, data[i]);
 798               		.loc 1 114 0 discriminator 3
 799 02d0 F601      		movw r30,r12
 800 02d2 4191      		ld r20,Z+
 801 02d4 6F01      		movw r12,r30
 802               	.LVL58:
 803 02d6 60E0      		ldi r22,0
 804 02d8 C801      		movw r24,r16
 805 02da 00D0      		rcall LCD_WRITE
 806               	.LVL59:
 112:LCD.c         **** 	for (uint8_t i=0; i<8; i++)
 807               		.loc 1 112 0 discriminator 3
 808 02dc CE14      		cp r12,r14
 809 02de DF04      		cpc r13,r15
 810 02e0 01F4      		brne .L36
 811               	/* epilogue start */
 812               	.LBE33:
 115:LCD.c         **** 	}
 116:LCD.c         **** }
 813               		.loc 1 116 0
 814 02e2 0F90      		pop __tmp_reg__
 815 02e4 DF91      		pop r29
 816 02e6 CF91      		pop r28
 817 02e8 1F91      		pop r17
 818 02ea 0F91      		pop r16
 819               	.LVL60:
 820 02ec FF90      		pop r15
 821 02ee EF90      		pop r14
 822 02f0 DF90      		pop r13
 823 02f2 CF90      		pop r12
 824               	.LVL61:
 825 02f4 0895      		ret
 826               		.cfi_endproc
 827               	.LFE21:
 829               	.global	LCD_INIT
 831               	LCD_INIT:
 832               	.LFB22:
 117:LCD.c         **** 
 118:LCD.c         **** void LCD_INIT(type_LCD *device)
 119:LCD.c         **** {
 833               		.loc 1 119 0
 834               		.cfi_startproc
 835               	.LVL62:
 836 02f6 FF92      		push r15
 837               	.LCFI36:
 838               		.cfi_def_cfa_offset 3
 839               		.cfi_offset 15, -2
 840 02f8 0F93      		push r16
 841               	.LCFI37:
 842               		.cfi_def_cfa_offset 4
 843               		.cfi_offset 16, -3
 844 02fa 1F93      		push r17
 845               	.LCFI38:
 846               		.cfi_def_cfa_offset 5
 847               		.cfi_offset 17, -4
 848 02fc CF93      		push r28
 849               	.LCFI39:
 850               		.cfi_def_cfa_offset 6
 851               		.cfi_offset 28, -5
 852 02fe DF93      		push r29
 853               	.LCFI40:
 854               		.cfi_def_cfa_offset 7
 855               		.cfi_offset 29, -6
 856               	/* prologue: function */
 857               	/* frame size = 0 */
 858               	/* stack size = 5 */
 859               	.L__stack_usage = 5
 860 0300 EC01      		movw r28,r24
 120:LCD.c         **** 	*device->ddr	|= 	(1<< device->pinNr_RS)	\
 861               		.loc 1 120 0
 862 0302 EC81      		ldd r30,Y+4
 863 0304 FD81      		ldd r31,Y+5
 864 0306 3081      		ld r19,Z
 865 0308 81E0      		ldi r24,lo8(1)
 866 030a 90E0      		ldi r25,0
 867               	.LVL63:
 868 030c BC01      		movw r22,r24
 869 030e 0F80      		ldd r0,Y+7
 870 0310 00C0      		rjmp 2f
 871               		1:
 872 0312 660F      		lsl r22
 873 0314 771F      		rol r23
 874               		2:
 875 0316 0A94      		dec r0
 876 0318 02F4      		brpl 1b
 121:LCD.c         **** 					|	(1<< device->pinNr_EN)	\
 877               		.loc 1 121 0
 878 031a AC01      		movw r20,r24
 879 031c 0E80      		ldd r0,Y+6
 880 031e 00C0      		rjmp 2f
 881               		1:
 882 0320 440F      		lsl r20
 883 0322 551F      		rol r21
 884               		2:
 885 0324 0A94      		dec r0
 886 0326 02F4      		brpl 1b
 120:LCD.c         **** 	*device->ddr	|= 	(1<< device->pinNr_RS)	\
 887               		.loc 1 120 0
 888 0328 462B      		or r20,r22
 889 032a 432B      		or r20,r19
 122:LCD.c         **** 					|	(1<< device->pinNr_D4)	\
 890               		.loc 1 122 0
 891 032c BC01      		movw r22,r24
 892 032e 0884      		ldd r0,Y+8
 893 0330 00C0      		rjmp 2f
 894               		1:
 895 0332 660F      		lsl r22
 896 0334 771F      		rol r23
 897               		2:
 898 0336 0A94      		dec r0
 899 0338 02F4      		brpl 1b
 900 033a 242F      		mov r18,r20
 901 033c 262B      		or r18,r22
 123:LCD.c         **** 					|	(1<< device->pinNr_D5)	\
 902               		.loc 1 123 0
 903 033e AC01      		movw r20,r24
 904 0340 0984      		ldd r0,Y+9
 905 0342 00C0      		rjmp 2f
 906               		1:
 907 0344 440F      		lsl r20
 908 0346 551F      		rol r21
 909               		2:
 910 0348 0A94      		dec r0
 911 034a 02F4      		brpl 1b
 912 034c 422B      		or r20,r18
 124:LCD.c         **** 					|	(1<< device->pinNr_D6)	\
 913               		.loc 1 124 0
 914 034e 9C01      		movw r18,r24
 915 0350 0A84      		ldd r0,Y+10
 916 0352 00C0      		rjmp 2f
 917               		1:
 918 0354 220F      		lsl r18
 919 0356 331F      		rol r19
 920               		2:
 921 0358 0A94      		dec r0
 922 035a 02F4      		brpl 1b
 923 035c 242B      		or r18,r20
 125:LCD.c         **** 					|	(1<< device->pinNr_D7);
 924               		.loc 1 125 0
 925 035e 0B84      		ldd r0,Y+11
 926 0360 00C0      		rjmp 2f
 927               		1:
 928 0362 880F      		lsl r24
 929 0364 991F      		rol r25
 930               		2:
 931 0366 0A94      		dec r0
 932 0368 02F4      		brpl 1b
 120:LCD.c         **** 					|	(1<< device->pinNr_EN)	\
 933               		.loc 1 120 0
 934 036a 822B      		or r24,r18
 935 036c 8083      		st Z,r24
 936               	.LVL64:
 937 036e 83E0      		ldi r24,lo8(3)
 938 0370 F82E      		mov r15,r24
 939               	.LBB34:
 126:LCD.c         **** 	for(uint8_t inits=0; inits<TIME_OF_INITS; inits++)
 127:LCD.c         **** 	{
 128:LCD.c         **** 		*device->port	|= 	(1<< device->pinNr_RS)	\
 940               		.loc 1 128 0
 941 0372 01E0      		ldi r16,lo8(1)
 942 0374 10E0      		ldi r17,0
 943               	.LVL65:
 944               	.L39:
 945               		.loc 1 128 0 is_stmt 0 discriminator 3
 946 0376 E881      		ld r30,Y
 947 0378 F981      		ldd r31,Y+1
 948 037a 9081      		ld r25,Z
 949 037c B801      		movw r22,r16
 950 037e 0F80      		ldd r0,Y+7
 951 0380 00C0      		rjmp 2f
 952               		1:
 953 0382 660F      		lsl r22
 954 0384 771F      		rol r23
 955               		2:
 956 0386 0A94      		dec r0
 957 0388 02F4      		brpl 1b
 129:LCD.c         **** 						|	(1<< device->pinNr_EN)	\
 958               		.loc 1 129 0 is_stmt 1 discriminator 3
 959 038a 9801      		movw r18,r16
 960 038c 0E80      		ldd r0,Y+6
 961 038e 00C0      		rjmp 2f
 962               		1:
 963 0390 220F      		lsl r18
 964 0392 331F      		rol r19
 965               		2:
 966 0394 0A94      		dec r0
 967 0396 02F4      		brpl 1b
 128:LCD.c         **** 						|	(1<< device->pinNr_EN)	\
 968               		.loc 1 128 0 discriminator 3
 969 0398 262B      		or r18,r22
 970 039a 292B      		or r18,r25
 130:LCD.c         **** 						|	(1<< device->pinNr_D4)	\
 971               		.loc 1 130 0 discriminator 3
 972 039c B801      		movw r22,r16
 973 039e 0884      		ldd r0,Y+8
 974 03a0 00C0      		rjmp 2f
 975               		1:
 976 03a2 660F      		lsl r22
 977 03a4 771F      		rol r23
 978               		2:
 979 03a6 0A94      		dec r0
 980 03a8 02F4      		brpl 1b
 981 03aa 262B      		or r18,r22
 131:LCD.c         **** 						|	(1<< device->pinNr_D5)	\
 982               		.loc 1 131 0 discriminator 3
 983 03ac A801      		movw r20,r16
 984 03ae 0984      		ldd r0,Y+9
 985 03b0 00C0      		rjmp 2f
 986               		1:
 987 03b2 440F      		lsl r20
 988 03b4 551F      		rol r21
 989               		2:
 990 03b6 0A94      		dec r0
 991 03b8 02F4      		brpl 1b
 992 03ba 822F      		mov r24,r18
 993 03bc 842B      		or r24,r20
 132:LCD.c         **** 						|	(1<< device->pinNr_D6)	\
 994               		.loc 1 132 0 discriminator 3
 995 03be 9801      		movw r18,r16
 996 03c0 0A84      		ldd r0,Y+10
 997 03c2 00C0      		rjmp 2f
 998               		1:
 999 03c4 220F      		lsl r18
 1000 03c6 331F      		rol r19
 1001               		2:
 1002 03c8 0A94      		dec r0
 1003 03ca 02F4      		brpl 1b
 1004 03cc 282B      		or r18,r24
 133:LCD.c         **** 						|	(1<< device->pinNr_D7);	
 1005               		.loc 1 133 0 discriminator 3
 1006 03ce C801      		movw r24,r16
 1007 03d0 0B84      		ldd r0,Y+11
 1008 03d2 00C0      		rjmp 2f
 1009               		1:
 1010 03d4 880F      		lsl r24
 1011 03d6 991F      		rol r25
 1012               		2:
 1013 03d8 0A94      		dec r0
 1014 03da 02F4      		brpl 1b
 128:LCD.c         **** 						|	(1<< device->pinNr_EN)	\
 1015               		.loc 1 128 0 discriminator 3
 1016 03dc 822B      		or r24,r18
 1017 03de 8083      		st Z,r24
 134:LCD.c         **** 						
 135:LCD.c         **** 		*device->port	&=~((1<< device->pinNr_RS)	\
 1018               		.loc 1 135 0 discriminator 3
 1019 03e0 E881      		ld r30,Y
 1020 03e2 F981      		ldd r31,Y+1
 1021 03e4 2081      		ld r18,Z
 136:LCD.c         **** 						|	(1<< device->pinNr_EN));
 1022               		.loc 1 136 0 discriminator 3
 1023 03e6 A801      		movw r20,r16
 1024 03e8 0E80      		ldd r0,Y+6
 1025 03ea 00C0      		rjmp 2f
 1026               		1:
 1027 03ec 440F      		lsl r20
 1028 03ee 551F      		rol r21
 1029               		2:
 1030 03f0 0A94      		dec r0
 1031 03f2 02F4      		brpl 1b
 135:LCD.c         **** 						|	(1<< device->pinNr_EN));
 1032               		.loc 1 135 0 discriminator 3
 1033 03f4 C801      		movw r24,r16
 1034 03f6 0F80      		ldd r0,Y+7
 1035 03f8 00C0      		rjmp 2f
 1036               		1:
 1037 03fa 880F      		lsl r24
 1038 03fc 991F      		rol r25
 1039               		2:
 1040 03fe 0A94      		dec r0
 1041 0400 02F4      		brpl 1b
 1042 0402 842B      		or r24,r20
 1043 0404 8095      		com r24
 1044 0406 8223      		and r24,r18
 1045 0408 8083      		st Z,r24
 1046               	.LVL66:
 1047               	.LBB35:
 1048               	.LBB36:
 163:/usr/avr/include/util/delay.h **** 
 1049               		.loc 2 163 0 discriminator 3
 1050 040a 87EC      		ldi r24,lo8(-20537)
 1051 040c 9FEA      		ldi r25,hi8(-20537)
 1052 040e 0197      		1: sbiw r24,1
 1053 0410 01F4      		brne 1b
 1054 0412 00C0      		rjmp .
 1055 0414 0000      		nop
 1056               	.LBE36:
 1057               	.LBE35:
 137:LCD.c         **** 		_delay_ms(15);
 138:LCD.c         **** 		*device->port	|= 	(1<< device->pinNr_EN);
 1058               		.loc 1 138 0 discriminator 3
 1059 0416 E881      		ld r30,Y
 1060 0418 F981      		ldd r31,Y+1
 1061 041a 2081      		ld r18,Z
 1062 041c C801      		movw r24,r16
 1063 041e 0E80      		ldd r0,Y+6
 1064 0420 00C0      		rjmp 2f
 1065               		1:
 1066 0422 880F      		lsl r24
 1067 0424 991F      		rol r25
 1068               		2:
 1069 0426 0A94      		dec r0
 1070 0428 02F4      		brpl 1b
 1071 042a 822B      		or r24,r18
 1072 042c 8083      		st Z,r24
 139:LCD.c         **** 		*device->port	&=~	(1<< device->pinNr_RS);
 1073               		.loc 1 139 0 discriminator 3
 1074 042e E881      		ld r30,Y
 1075 0430 F981      		ldd r31,Y+1
 1076 0432 9081      		ld r25,Z
 1077 0434 9801      		movw r18,r16
 1078 0436 0F80      		ldd r0,Y+7
 1079 0438 00C0      		rjmp 2f
 1080               		1:
 1081 043a 220F      		lsl r18
 1082 043c 331F      		rol r19
 1083               		2:
 1084 043e 0A94      		dec r0
 1085 0440 02F4      		brpl 1b
 1086 0442 822F      		mov r24,r18
 1087 0444 8095      		com r24
 1088 0446 8923      		and r24,r25
 1089 0448 8083      		st Z,r24
 140:LCD.c         **** 		LCD_ENABLE(device);
 1090               		.loc 1 140 0 discriminator 3
 1091 044a CE01      		movw r24,r28
 1092 044c 00D0      		rcall LCD_ENABLE
 1093               	.LVL67:
 1094               	.LBB37:
 1095               	.LBB38:
 163:/usr/avr/include/util/delay.h **** 
 1096               		.loc 2 163 0 discriminator 3
 1097 044e 87E9      		ldi r24,lo8(14999)
 1098 0450 9AE3      		ldi r25,hi8(14999)
 1099 0452 0197      		1: sbiw r24,1
 1100 0454 01F4      		brne 1b
 1101 0456 00C0      		rjmp .
 1102 0458 0000      		nop
 1103               	.LBE38:
 1104               	.LBE37:
 141:LCD.c         **** 		_delay_ms(5);
 142:LCD.c         **** 		LCD_ENABLE(device);
 1105               		.loc 1 142 0 discriminator 3
 1106 045a CE01      		movw r24,r28
 1107 045c 00D0      		rcall LCD_ENABLE
 1108               	.LVL68:
 1109               	.LBB39:
 1110               	.LBB40:
 1111               		.loc 2 245 0 discriminator 3
 1112 045e 8BE2      		ldi r24,lo8(299)
 1113 0460 91E0      		ldi r25,hi8(299)
 1114 0462 0197      		1: sbiw r24,1
 1115 0464 01F4      		brne 1b
 1116 0466 00C0      		rjmp .
 1117 0468 0000      		nop
 1118               	.LBE40:
 1119               	.LBE39:
 143:LCD.c         **** 		_delay_us(100);
 144:LCD.c         **** 		LCD_ENABLE(device);
 1120               		.loc 1 144 0 discriminator 3
 1121 046a CE01      		movw r24,r28
 1122 046c 00D0      		rcall LCD_ENABLE
 1123               	.LVL69:
 1124               	.LBB41:
 1125               	.LBB42:
 1126               		.loc 2 245 0 discriminator 3
 1127 046e 8BE2      		ldi r24,lo8(299)
 1128 0470 91E0      		ldi r25,hi8(299)
 1129 0472 0197      		1: sbiw r24,1
 1130 0474 01F4      		brne 1b
 1131 0476 00C0      		rjmp .
 1132 0478 0000      		nop
 1133               	.LBE42:
 1134               	.LBE41:
 145:LCD.c         **** 		_delay_us(100);
 146:LCD.c         **** 		LCD_SETPINS(device, 0x02);
 1135               		.loc 1 146 0 discriminator 3
 1136 047a 62E0      		ldi r22,lo8(2)
 1137 047c CE01      		movw r24,r28
 1138 047e 00D0      		rcall LCD_SETPINS
 1139               	.LVL70:
 147:LCD.c         **** 		LCD_ENABLE(device);
 1140               		.loc 1 147 0 discriminator 3
 1141 0480 CE01      		movw r24,r28
 1142 0482 00D0      		rcall LCD_ENABLE
 1143               	.LVL71:
 1144               	.LBB43:
 1145               	.LBB44:
 1146               		.loc 2 245 0 discriminator 3
 1147 0484 8BE2      		ldi r24,lo8(299)
 1148 0486 91E0      		ldi r25,hi8(299)
 1149 0488 0197      		1: sbiw r24,1
 1150 048a 01F4      		brne 1b
 1151 048c 00C0      		rjmp .
 1152 048e 0000      		nop
 1153               	.LBE44:
 1154               	.LBE43:
 148:LCD.c         **** 		_delay_us(100);
 149:LCD.c         **** 		LCD_WRITE(device, LCD_CMD, 0x28);
 1155               		.loc 1 149 0 discriminator 3
 1156 0490 48E2      		ldi r20,lo8(40)
 1157 0492 61E0      		ldi r22,lo8(1)
 1158 0494 CE01      		movw r24,r28
 1159 0496 00D0      		rcall LCD_WRITE
 1160               	.LVL72:
 150:LCD.c         **** 		LCD_WRITE(device, LCD_CMD, 0x08);
 1161               		.loc 1 150 0 discriminator 3
 1162 0498 48E0      		ldi r20,lo8(8)
 1163 049a 61E0      		ldi r22,lo8(1)
 1164 049c CE01      		movw r24,r28
 1165 049e 00D0      		rcall LCD_WRITE
 1166               	.LVL73:
 151:LCD.c         **** 		LCD_WRITE(device, LCD_CMD, 0x01);
 1167               		.loc 1 151 0 discriminator 3
 1168 04a0 41E0      		ldi r20,lo8(1)
 1169 04a2 61E0      		ldi r22,lo8(1)
 1170 04a4 CE01      		movw r24,r28
 1171 04a6 00D0      		rcall LCD_WRITE
 1172               	.LVL74:
 152:LCD.c         **** 		LCD_WRITE(device, LCD_CMD, 0x06);
 1173               		.loc 1 152 0 discriminator 3
 1174 04a8 46E0      		ldi r20,lo8(6)
 1175 04aa 61E0      		ldi r22,lo8(1)
 1176 04ac CE01      		movw r24,r28
 1177 04ae 00D0      		rcall LCD_WRITE
 1178               	.LVL75:
 153:LCD.c         **** 		LCD_WRITE(device, LCD_CMD, 0x0C);
 1179               		.loc 1 153 0 discriminator 3
 1180 04b0 4CE0      		ldi r20,lo8(12)
 1181 04b2 61E0      		ldi r22,lo8(1)
 1182 04b4 CE01      		movw r24,r28
 1183 04b6 00D0      		rcall LCD_WRITE
 1184               	.LVL76:
 154:LCD.c         **** 		LCD_WRITE(device, LCD_CMD, 0b00000001);
 1185               		.loc 1 154 0 discriminator 3
 1186 04b8 41E0      		ldi r20,lo8(1)
 1187 04ba 61E0      		ldi r22,lo8(1)
 1188 04bc CE01      		movw r24,r28
 1189 04be 00D0      		rcall LCD_WRITE
 1190               	.LVL77:
 1191               	.LBB45:
 1192               	.LBB46:
 163:/usr/avr/include/util/delay.h **** 
 1193               		.loc 2 163 0 discriminator 3
 1194 04c0 9FE7      		ldi r25,lo8(239999)
 1195 04c2 29EA      		ldi r18,hi8(239999)
 1196 04c4 83E0      		ldi r24,hlo8(239999)
 1197 04c6 9150      		1: subi r25,1
 1198 04c8 2040      		sbci r18,0
 1199 04ca 8040      		sbci r24,0
 1200 04cc 01F4      		brne 1b
 1201 04ce 00C0      		rjmp .
 1202 04d0 0000      		nop
 1203               	.LVL78:
 1204 04d2 FA94      		dec r15
 1205               	.LVL79:
 1206               	.LBE46:
 1207               	.LBE45:
 126:LCD.c         **** 	{
 1208               		.loc 1 126 0 discriminator 3
 1209 04d4 F110      		cpse r15,__zero_reg__
 1210 04d6 00C0      		rjmp .L39
 1211               	/* epilogue start */
 1212               	.LBE34:
 155:LCD.c         **** 		_delay_ms(100);
 156:LCD.c         **** 	}
 157:LCD.c         **** }
 1213               		.loc 1 157 0
 1214 04d8 DF91      		pop r29
 1215 04da CF91      		pop r28
 1216               	.LVL80:
 1217 04dc 1F91      		pop r17
 1218 04de 0F91      		pop r16
 1219 04e0 FF90      		pop r15
 1220               	.LVL81:
 1221 04e2 0895      		ret
 1222               		.cfi_endproc
 1223               	.LFE22:
 1225               	.Letext0:
 1226               		.file 4 "/usr/avr/include/stdint.h"
 1227               		.file 5 "LCD.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 LCD.c
     /tmp/cczyxcTc.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cczyxcTc.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cczyxcTc.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cczyxcTc.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cczyxcTc.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cczyxcTc.s:12     .text:0000000000000000 LCD_SETPINS
     /tmp/cczyxcTc.s:174    .text:00000000000000ce LCD_ENABLE
     /tmp/cczyxcTc.s:233    .text:000000000000010c LCD_WRITE
     /tmp/cczyxcTc.s:392    .text:00000000000001b0 LCD_STRING
     /tmp/cczyxcTc.s:449    .text:00000000000001d4 LCD_CLEAR
     /tmp/cczyxcTc.s:468    .text:00000000000001da LCD_HOME
     /tmp/cczyxcTc.s:487    .text:00000000000001e0 LCD_POS
     /tmp/cczyxcTc.s:512    .text:00000000000001ee LCD_INTX
     /tmp/cczyxcTc.s:592    .text:0000000000000234 LCD_INT
     /tmp/cczyxcTc.s:611    .text:000000000000023a LCD_FLOATX
     /tmp/cczyxcTc.s:696    .text:0000000000000288 LCD_FLOAT
     /tmp/cczyxcTc.s:723    .text:0000000000000294 LCD_GENERATECHAR
     /tmp/cczyxcTc.s:831    .text:00000000000002f6 LCD_INIT

UNDEFINED SYMBOLS
__itoa
dtostrf
